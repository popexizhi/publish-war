<map version="1.0.1">
<!-- To view this file, download free mind mapping software FreeMind from http://freemind.sourceforge.net -->
<node CREATED="1401184725152" ID="ID_468641799" MODIFIED="1401184746183" TEXT="Chapter 15. Refactoring ">
<node CREATED="1401184900870" FOLDED="true" ID="ID_261376962" MODIFIED="1422407625325" POSITION="right" TEXT="15.1. Handling bugs ">
<node CREATED="1401184964323" ID="ID_1905489652" MODIFIED="1403602676184">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Despite your best efforts to write comprehensive unit tests, bugs happen. What do I mean by "bug"? A bug is a test case you&#xa0;haven't written yet.
    </p>
    <p>
      [pope &#x8bd1;]
    </p>
    <p>
      &#x5c3d;&#x7ba1;&#x4f60;&#x505a;&#x4e86;&#x6700;&#x5b8c;&#x6210;&#x7684;&#x5355;&#x5143;&#x6d4b;&#x8bd5;&#xff0c;&#x4f46;bugs&#x8fd8;&#x662f;&#x51fa;&#x73b0;&#x4e86;&#x3002;&#x90a3;bug&#x53c8;&#x610f;&#x5473;&#x7740;&#x4ec0;&#x4e48;&#x5462;&#xff1f;&#x4e00;&#x4e2a;bug&#x5c31;&#x662f;&#x4e00;&#x4e2a;&#x4f60;&#x8fd8;&#x6ca1;&#x6709;&#x5199;&#x7684;&#x6d4b;&#x8bd5;&#x7528;&#x4f8b;
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1403602763200" FOLDED="true" ID="ID_1802641986" MODIFIED="1404806675171" TEXT="Example 15.1. The bug">
<node CREATED="1403603175653" ID="ID_1353120047" MODIFIED="1403603202293">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      &gt;&gt;&gt; import roman5
    </p>
    <p>
      &gt;&gt;&gt; roman5.fromRoman("") ------------------------------1
    </p>
    <p>
      0
    </p>
  </body>
</html></richcontent>
<node CREATED="1403603203950" ID="ID_72245657" MODIFIED="1404806360250">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      1.
    </p>
    <p>
      Remember in the previous section when you kept seeing that an empty string would match the regular expression you were using to check for valid Roman numerals? Well, it turns out that this is still true for the&#xa0;final version of the regular expression. And that's a bug; you want an empty string to raise an&#xa0;&#xa0;InvalidRomanNumeralError exception just like any other sequence of characters that don't represent a valid Roman numeral.
    </p>
    <p>
      [pope&#x8bd1;]
    </p>
    <p>
      &#x53ef;&#x8bb0;&#x7684;&#x524d;&#x7ae0;&#x66fe;&#x89c1;&#x7a7a;&#x4e32;&#x7b26;&#x5408;&#x7f57;&#x9a6c;&#x6570;&#x5b57;&#x7684;&#x68c0;&#x67e5;&#xff1f;&#x662f;&#xff0c;&#x6b64;&#x7248;&#x672c;&#x6b63;&#x5219;&#x68c0;&#x67e5;&#x51fa;&#x7684;&#x95ee;&#x9898;&#x663e;&#x793a;&#x4e3a;&#x771f;&#x3002;&#x662f;&#x4e2a;bug&#xff0c;&#x4f60;&#x672c;&#x610f;&#x7a7a;&#x4e32;&#x4e3a;&#x5047; &#x629b;&#x51fa; &#xa0;InvalidRomanNumeralError&#x5f02;&#x5e38; &#xff0c;&#x5c31;&#x50cf;&#x5176;&#x4ed6;&#x975e;&#x7f57;&#x9a6c;&#x6570;&#x5b57;&#x5217;&#x8868;&#x3002;
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1404806366968" ID="ID_417512030" MODIFIED="1404806534750">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      After reproducing&#xa0;the bug, and before fixing it, you should write a test case that fails, thus illustrating the bug
    </p>
    <p>
      [pope &#x8bd1;]
    </p>
    <p>
      &#x91cd;&#x73b0;&#x6b64;bug&#x540e;&#xff0c;&#x4fee;&#x590d;&#x524d;&#xff0c;&#x4f60;&#x5f53;&#x5199;&#x6b64;&#x5931;&#x6548;&#x7684;&#x6d4b;&#x8bd5;&#x7528;&#x4f8b;&#xff0c;&#x6765;&#x8bb0;&#x8ff0;{illustrating}&#x6b64;bug
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1404806605296" ID="ID_1594664854" MODIFIED="1404806606546" TEXT="Example 15.2. Testing for the bug (romantest61.py)">
<node CREATED="1404806616781" ID="ID_547024989" MODIFIED="1404806624296">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      class FromRomanBadInput(unittest.TestCase):&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;# previous test cases omitted for clarity (they haven't changed)
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;def testBlank(self):
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;"""fromRoman should fail with blank string"""
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;self.assertRaises(roman.InvalidRomanNumeralError, roman.fromRoman, "")&#xa0;&#xa0;&#xa0;--------------------1
    </p>
  </body>
</html></richcontent>
<node CREATED="1404806669281" ID="ID_36402773" MODIFIED="1404806978250">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      1
    </p>
    <p>
      Pretty simple stuff here. Call fromRoman with an empty string and make sure it raises an InvalidRomanNumeralError exception. The hard part was finding the bug; now that you know about it, testing for it is the easy part.
    </p>
    <p>
      [pope&#x8bd1;]
    </p>
    <p>
      &#x6b64;&#x5904;&#x9887;{pretty}&#x7b80;&#x5355;.&#x7528;&#x7a7a;&#x4e32;&#x8c03;fromRoman&#xff0c;&#x4e14;&#x786e;&#x5b9a;&#x6b64;&#x5f53;&#x629b;InvalidRomanNumeralError&#x5f02;&#x5e38;&#x3002;&#x96be;&#x51fa;&#x662f;&#x53d1;&#x73b0;&#x6b64;bug&#xff1b;&#x73b0;&#x5728;&#x541b;&#x5f53;&#x77e5;testing&#x624d;&#x662f;&#x7b80;&#x5355;&#x7684;&#x90e8;&#x5206;&#x800c;&#x5df2;&#x3002;
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1404807012953" FOLDED="true" ID="ID_910147028" MODIFIED="1404807163453">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Since your code has a bug, and you now have a test case that tests this bug, the test case will fail
    </p>
    <p>
      [pope&#x8bd1;]
    </p>
    <p>
      &#x56e0;code&#x6709;bug&#xff0c;&#x4e14;&#x73b0;&#x5728;&#x6709;&#x6b64;bug&#x7684;&#x6d4b;&#x8bd5;&#x7528;&#x4f8b;&#xff0c;&#x6b64;&#x7528;&#x4f8b;&#x6267;&#x884c;&#x5931;&#x8d25;&#x5982;&#x4e0b;:
    </p>
  </body>
</html></richcontent>
<node CREATED="1404807141078" ID="ID_1138041004" MODIFIED="1404807157171">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Example 15.3. Output of romantest61.py against roman61.py
    </p>
    <p>
      fromRoman should only accept uppercase input ... ok
    </p>
    <p>
      toRoman should always return uppercase ... ok
    </p>
    <p>
      fromRoman should fail with blank string ... FAIL
    </p>
    <p>
      fromRoman should fail with malformed antecedents ... ok
    </p>
    <p>
      fromRoman should fail with repeated pairs of numerals ... ok
    </p>
    <p>
      fromRoman should fail with too many repeated numerals ... ok
    </p>
    <p>
      fromRoman should give known result with known input ... ok
    </p>
    <p>
      toRoman should give known result with known input ... ok
    </p>
    <p>
      fromRoman(toRoman(n))==n for all n ... ok
    </p>
    <p>
      toRoman should fail with non&#x2212;integer input ... ok
    </p>
    <p>
      toRoman should fail with negative input ... ok
    </p>
    <p>
      toRoman should fail with large input ... ok
    </p>
    <p>
      toRoman should fail with 0 input ... ok
    </p>
    <p>
      ======================================================================
    </p>
    <p>
      FAIL: fromRoman should fail with blank string
    </p>
    <p>
      &#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;
    </p>
    <p>
      Traceback (most recent call last):
    </p>
    <p>
      &#xa0;&#xa0;File "C:\docbook\dip\py\roman\stage6\romantest61.py", line 137, in testBlank
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;self.assertRaises(roman61.InvalidRomanNumeralError, roman61.fromRoman, "")
    </p>
    <p>
      &#xa0;&#xa0;File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;raise self.failureException, excName
    </p>
    <p>
      AssertionError: InvalidRomanNumeralError
    </p>
    <p>
      &#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;
    </p>
    <p>
      Ran 13 tests in 2.864s
    </p>
    <p>
      FAILED (failures=1)
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1404807161421" ID="ID_1152307237" MODIFIED="1404807198328">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Now you can fix the bug.
    </p>
    <p>
      [pope &#x8bd1;]
    </p>
    <p>
      &#x73b0;&#x5728;&#x6765;&#x4fee;&#x590d;&#x6b64;bug
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1404807255953" FOLDED="true" ID="ID_1778868380" MODIFIED="1404808128265" TEXT="Example 15.4. Fixing the bug (roman62.py)">
<node CREATED="1404807270437" ID="ID_914062268" MODIFIED="1404807331343">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      This file is available in py/roman/stage6/ in the examples directory
    </p>
    <p>
      [pope &#x8bd1;]
    </p>
    <p>
      &#x6b64;&#x6587;py/roman/stage6/ &#x5b9e;&#x4f8b;&#x6587;&#x4ef6;&#x4e2d;
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1404807355859" ID="ID_552048762" MODIFIED="1404807366546">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      def fromRoman(s):
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;"""convert Roman numeral to integer"""
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;if not s:&#xa0; ------------------------------------------------------------------------------1
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;raise InvalidRomanNumeralError, 'Input can not be blank'
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;if not re.search(romanNumeralPattern, s):
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;result = 0
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;index = 0
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;for numeral, integer in romanNumeralMap:
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;while s[index:index+len(numeral)] == numeral:
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;result += integer
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;index += len(numeral)
    </p>
    <p>
      &#xa0;&#xa0;&#xa0;&#xa0;return result
    </p>
  </body>
</html></richcontent>
<node CREATED="1404807368625" ID="ID_1156337751" MODIFIED="1404807863203">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      1
    </p>
    <p>
      Only two lines of code are required: an explicit check for an empty string, and a raise statement.
    </p>
    <p>
      [pope&#x8bd1;]
    </p>
    <p>
      &#x53ea;&#x9700;&#x4e24;&#x884c;&#x4ee3;&#x7801;:&#x660e;&#x786e;&#x67e5;&#x7a7a;&#x4e32;&#xff0c;&#x629b;&#x5f02;&#x5e38;&#x58f0;&#x660e;
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1404807896968" FOLDED="true" ID="ID_175023558" MODIFIED="1404808127000" TEXT="Example 15.5. Output of romantest62.py against roman62.py">
<node CREATED="1404807899500" ID="ID_748425489" MODIFIED="1404807935062">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      fromRoman should only accept uppercase input ... ok
    </p>
    <p>
      toRoman should always return uppercase ... ok
    </p>
    <p>
      fromRoman should fail with blank string ... ok&#xa0; --------------------------------------------------------1
    </p>
    <p>
      fromRoman should fail with malformed antecedents ... ok
    </p>
    <p>
      fromRoman should fail with repeated pairs of numerals ... ok
    </p>
    <p>
      fromRoman should fail with too many repeated numerals ... ok
    </p>
    <p>
      fromRoman should give known result with known input ... ok
    </p>
    <p>
      toRoman should give known result with known input ... ok
    </p>
    <p>
      fromRoman(toRoman(n))==n for all n ... ok
    </p>
    <p>
      toRoman should fail with non&#x2212;integer input ... ok
    </p>
    <p>
      toRoman should fail with negative input ... ok
    </p>
    <p>
      toRoman should fail with large input ... ok
    </p>
    <p>
      toRoman should fail with 0 input ... ok
    </p>
    <p>
      &#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;&#x2212;
    </p>
    <p>
      Ran 13 tests in 2.834s
    </p>
    <p>
      OK&#xa0; --------------------------------------------------------2
    </p>
  </body>
</html></richcontent>
<node CREATED="1404807965296" ID="ID_339616174" MODIFIED="1404808011453">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      1
    </p>
    <p>
      The blank string test case now passes, so the bug is fixed
    </p>
    <p>
      [pope&#x8bd1;]
    </p>
    <p>
      &#x7a7a;&#x4e32;&#x6d4b;&#x8bd5;&#x7528;&#x4f8b;&#x901a;&#x8fc7;&#xff0c;&#x6b64;bug&#x4fee;&#x590d;
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1404808029156" ID="ID_1432747169" MODIFIED="1404808105703">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      2.
    </p>
    <p>
      All the other test cases still pass, which means that this bug fix didn't break anything else. Stop coding
    </p>
    <p>
      [pope&#x8bd1;]
    </p>
    <p>
      &#x5168;&#x90e8;&#x6d4b;&#x8bd5;&#x7528;&#x4f8b;&#x901a;&#x8fc7;&#xff0c;&#x8fd9;&#x610f;&#x5473;&#x4fee;&#x590d;bug&#x672a;&#x5f15;&#x5165;&#x5176;&#x4ed6;&#x3002;&#x505c;&#x6b62;&#x7f16;&#x7a0b;&#x4e86;
    </p>
  </body>
</html></richcontent>
</node>
</node>
</node>
<node CREATED="1404808131203" ID="ID_254861937" MODIFIED="1422407571542">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Coding this way does not make fixing bugs any easier. Simple bugs (like this one) require simple test cases; complex bugs will require complex test cases.
    </p>
    <p>
      In a testing&#8722;centric environment, it may seem like it takes longer to fix a bug, since you need to articulate in code exactly what the bug is (to write the test case), then fix the bug itself.
    </p>
    <p>
      Then if the test case doesn't pass right away, you need to figure out whether the fix was wrong, or whether the test case itself has a bug in it.
    </p>
    <p>
      
    </p>
    <p>
      [pope&#35793;]
    </p>
    <p>
      &#36825;&#31181;&#32534;&#30721;&#26041;&#24335;&#24182;&#19981;&#33021;&#26356;&#31616;&#21333;&#30340;&#20462;&#22797;bug&#12290;&#31616;&#21333;&#30340;bug&#65288;&#20687;&#36825;&#20010;&#65289;&#38656;&#35201;&#31616;&#21333;&#30340;&#27979;&#35797;&#29992;&#20363;&#65307;&#22797;&#26434;&#30340;bug&#20250;&#38656;&#35201;&#22797;&#26434;&#30340;&#27979;&#35797;&#29992;&#20363;&#12290;
    </p>
    <p>
      &#22312;&#27979;&#35797;&#20013;&#65292;&#30475;&#36215;&#26469;&#26356;&#20687;&#29992;&#36739;&#38271;&#26102;&#38388;&#20462;&#22797;bug&#65292;&#20320;&#38656;&#35201;&#26126;&#30830;{articulate}&#20195;&#30721;&#20013;&#36825;&#20010;bug&#30340;&#20160;&#20040;(&#24182;&#20889;&#21040;&#27979;&#35797;&#29992;&#20363;&#20013;)&#65292;&#28982;&#21518;&#20462;&#22797;&#36825;&#20010;bug&#12290;
    </p>
    <p>
      &#37027;&#20040;&#22914;&#26524;&#27979;&#35797;&#29992;&#20363;&#24182;&#27809;&#26377;&#20351;&#29992;&#27491;&#30830;&#30340;&#26041;&#24335;&#27979;&#35797;&#36890;&#36807;&#65292;&#20320;&#38656;&#35201;&#24819;&#24819;{}&#36825;&#20010;&#20462;&#22797;&#26159;&#21542;&#26159;&#38169;&#35823;&#30340;&#65292;&#25110;&#32773;&#36825;&#20010;&#27979;&#35797;&#29992;&#20363;&#26412;&#36523;&#26377;bug
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1421804421919" ID="ID_1860935668" MODIFIED="1422407465213">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      However, in the long run, this back&#8722;and&#8722;forth between test code and code tested pays for itself, because it makes it more likely that bugs are fixed correctly the first time. Also, since you can easily re&#8722;run all the test cases along with your new one, you are much less likely to break old code when fixing new code. Today's unit test is tomorrow's regression test
    </p>
    <p>
      [pope&#35793;]
    </p>
    <p>
      &#26080;&#35770;&#22914;&#20309;,&#22312;&#38271;&#26102;&#38388;&#36807;&#21435;&#21518;&#65292;&#37325;&#25342;&#20043;&#21069;&#30340;&#27979;&#35797;&#20195;&#30721;&#21644;&#34987;&#27979;&#35797;&#30340;&#20195;&#30721;&#65292;&#36825;&#20010;&#36807;&#31243;&#20351;&#24471;&#23427;&#30475;&#36215;&#26469;&#26356;&#20687;&#26159;bug&#20204;&#22312;&#31532;&#19968;&#26102;&#38388;&#34987;&#20934;&#30830;&#30340;&#20462;&#22797;&#20102;&#12290;&#24182;&#19988;&#65292;&#22312;&#20320;&#30340;&#28155;&#21152;&#26032;&#20869;&#23481;&#21518;&#65292;&#20320;&#23601;&#21487;&#20197;&#31616;&#21333;&#30340;&#36816;&#34892;&#20840;&#37096;&#27979;&#35797;&#29992;&#20363;&#20102;&#65292;&#36825;&#26679;&#20320;&#21487;&#20197;&#22312;&#28155;&#21152;&#26032;&#20195;&#30721;&#26102;&#26356;&#23569;&#30340;&#25171;&#20081;&#26087;&#20195;&#30721;&#20102;&#12290;&#20170;&#22825;&#30340;&#21333;&#20803;&#27979;&#35797;&#23601;&#26159;&#26126;&#22825;&#30340;&#38450;&#27490;&#36864;&#21270;&#30340;&#27979;&#35797;{regression test}
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1422407855423" ID="ID_1924784698" MODIFIED="1422407866858" POSITION="right">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      15.2. Handling changing requirements
    </p>
  </body>
</html></richcontent>
<node CREATED="1422407934896" ID="ID_1313742305" MODIFIED="1423011698062">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Despite your best efforts to pin your customers to the ground and extract exact requirements from them&#160;on pain of horrible nasty things involving scissors and hot wax, requirements will change.
    </p>
    <p>
      Most customers don't know what they want until they see it, and even if they do, they aren't that good at articulating what they want precisely enough to be useful. And even if they do, they'll want more in the next release anyway. So be prepared to update your test cases as requirements change.
    </p>
    <p>
      
    </p>
    <p>
      [pope&#35793;] &#23613;&#31649;{despite}&#20320;&#23613;&#21147;{efforts}&#31449;&#22312;{pin}&#23458;&#25143;&#30340;&#35282;&#24230;&#65292;&#25552;&#21462;&#20986;{extract}&#20934;&#30830;&#30340;{exact}&#38656;&#27714;&#65292;&#26469;&#33258;&#20110;&#20182;&#20204;&#21487;&#24597;{horribe}&#27745;&#31229;{nasty}&#20043;&#29289;&#30340;&#30171;&#33510;{pain} &#21253;&#25324; &#21098;&#20992;{scissors}&#21644;&#24456;&#28907;&#30340;&#34593;&#27833;{hot wax},&#38656;&#27714;&#36824;&#26159;&#20250;&#21464;&#21160;&#12290;
    </p>
    <p>
      &#22810;&#25968;&#23458;&#25143;&#24182;&#19981;&#30693;&#36947;&#20182;&#20204;&#21040;&#24213;&#35201;&#20160;&#20040;&#30452;&#21040;&#20182;&#20204;&#30475;&#21040;&#25152;&#35201;&#30340;&#65307;&#24182;&#19988;&#21363;&#20351;&#20182;&#20204;&#30693;&#36947;&#33258;&#24049;&#24819;&#35201;&#20160;&#20040;&#65292;&#20182;&#20204;&#20063;&#19981;&#33021;&#28165;&#26224;&#30340;{articulating}&#25551;&#36848;&#20986;&#20160;&#20040;&#23545;&#20182;&#20204;&#26377;&#29992;;&#24182;&#19988;&#21363;&#20351;&#20182;&#20204;&#21487;&#20197;&#28165;&#26224;&#25551;&#36848;&#20182;&#20204;&#24819;&#35201;&#30340;&#65292;&#20182;&#20204;&#20063;&#23558;&#22312;&#19979;&#20010;&#29256;&#26412;&#35201;&#27714;&#30340;&#26356;&#22810;&#12290;&#25152;&#20197;&#20934;&#22791;{prepared}&#26356;&#26032;&#20320;&#30340;&#27979;&#35797;&#29992;&#20363;&#22312;&#38656;&#27714;&#25913;&#21464;&#26102;&#12290;
    </p>
    <p>
      [popexizhi]&quot;from them&#160;on pain of horrible nasty things involving scissors and hot wax&quot;&#36825;&#20010;&#30340;&#20934;&#30830;&#32763;&#35793;&#26159;&#20160;&#20040;&#27604;&#36739;&#22909;&#21602;&#65311;&#20174;&#27700;&#28145;&#28779;&#28909;&#20013;&#25250;&#25937;&#20986;?! :)&#22909;&#21543;&#21453;&#27491;&#26159;&#29712;&#30862;&#30171;&#33510;&#30340;&#20107;&#12290;
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1422493350012" ID="ID_1411570008" MODIFIED="1423011073136">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      Suppose, for instance, that you wanted to expand the range of the Roman numeral conversion functions. Remember the rule that said that no character could be repeated more than three times? Well, the Romans were willing to make an exception to that rule by having 4 M characters in a row to represent 4000. If you make this change, you'll be able to expand the range of convertible numbers from 1..3999 to 1..4999. But first, you need to make some changes to the test cases.
    </p>
    <p>
      
    </p>
    <p>
      [pope&#35793;]
    </p>
    <p>
      &#20551;&#35774;&#65292;&#36825;&#20010;&#20363;&#23376;&#20013;&#65292;&#20320;&#24819;&#35201;&#25193;&#23637;&#32599;&#39532;&#23383;&#31526;&#36716;&#25442;&#20989;&#25968;&#30340;&#34892;&#21015;&#20869;&#23481;&#12290;&#35760;&#24471;&#37027;&#20010;&#35268;&#21017;&#35828;&#30340;&#26159;&#19981;&#33021;&#26377;&#23383;&#31526;&#22810;&#20110;&#19977;&#27425;&#20986;&#29616;&#21527;&#65311;&#24456;&#22909;&#65292;&#32599;&#39532;&#23383;&#27597;&#23558;&#25193;&#23637;&#36825;&#20010;&#35268;&#21017;&#20026;&#21487;&#20197;&#26377;4&#20010;M&#26469;&#25551;&#36848;4000.&#22914;&#26524;&#20320;&#23454;&#29616;&#36825;&#20010;&#25913;&#21464;&#65292;&#20320;&#23558;&#25193;&#23637;&#36825;&#20010;&#23383;&#31526;&#20018;&#20174;1&#65374;3999&#20026;1&#65374;4999.&#20294;&#39318;&#20808;&#20320;&#38656;&#35201;&#22312;&#27979;&#35797;&#29992;&#20363;&#20013;&#20570;&#19968;&#20123;&#25913;&#21464;&#12290;
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1423011738133" ID="ID_1967764476" MODIFIED="1423011739774" TEXT="Example 15.6. Modifying test cases for new requirements (romantest71.py) ">
<node CREATED="1423012354004" FOLDED="true" ID="ID_510291935" MODIFIED="1423097186712" TEXT="code">
<node CREATED="1423012382430" ID="ID_1228557660" MODIFIED="1423012392343">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      import roman71
    </p>
    <p>
      import unittest
    </p>
    <p>
      class KnownValues(unittest.TestCase):
    </p>
    <p>
      knownValues = ( (1, 'I'),
    </p>
    <p>
      (2, 'II'),
    </p>
    <p>
      (3, 'III'),
    </p>
    <p>
      (4, 'IV'),
    </p>
    <p>
      (5, 'V'),
    </p>
    <p>
      (6, 'VI'),
    </p>
    <p>
      (7, 'VII'),
    </p>
    <p>
      (8, 'VIII'),
    </p>
    <p>
      (9, 'IX'),
    </p>
    <p>
      (10, 'X'),
    </p>
    <p>
      (50, 'L'),
    </p>
    <p>
      (100, 'C'),
    </p>
    <p>
      (500, 'D'),
    </p>
    <p>
      (1000, 'M'),
    </p>
    <p>
      (31, 'XXXI'),
    </p>
    <p>
      (148, 'CXLVIII'),
    </p>
    <p>
      (294, 'CCXCIV'),
    </p>
    <p>
      (312, 'CCCXII'),
    </p>
    <p>
      (421, 'CDXXI'),
    </p>
    <p>
      (528, 'DXXVIII'),
    </p>
    <p>
      (621, 'DCXXI'),
    </p>
    <p>
      (782, 'DCCLXXXII'),
    </p>
    <p>
      (870, 'DCCCLXX'),
    </p>
    <p>
      (941, 'CMXLI'),
    </p>
    <p>
      (1043, 'MXLIII'),
    </p>
    <p>
      (1110, 'MCX'),
    </p>
    <p>
      (1226, 'MCCXXVI'),
    </p>
    <p>
      (1301, 'MCCCI'),
    </p>
    <p>
      (1485, 'MCDLXXXV'),
    </p>
    <p>
      (1509, 'MDIX'),
    </p>
    <p>
      (1607, 'MDCVII'),
    </p>
    <p>
      (1754, 'MDCCLIV'),
    </p>
    <p>
      (1832, 'MDCCCXXXII'),
    </p>
    <p>
      (1993, 'MCMXCIII'),
    </p>
    <p>
      (2074, 'MMLXXIV'),
    </p>
    <p>
      (2152, 'MMCLII'),
    </p>
    <p>
      (2212, 'MMCCXII'),
    </p>
    <p>
      (2343, 'MMCCCXLIII'),
    </p>
    <p>
      (2499, 'MMCDXCIX'),
    </p>
    <p>
      (2574, 'MMDLXXIV'),
    </p>
    <p>
      (2646, 'MMDCXLVI'),
    </p>
    <p>
      (2723, 'MMDCCXXIII'),
    </p>
    <p>
      (2892, 'MMDCCCXCII'),
    </p>
    <p>
      (2975, 'MMCMLXXV'),
    </p>
    <p>
      (3051, 'MMMLI'),
    </p>
    <p>
      (3185, 'MMMCLXXXV'),
    </p>
    <p>
      (3250, 'MMMCCL'),
    </p>
    <p>
      (3313, 'MMMCCCXIII'),
    </p>
    <p>
      (3408, 'MMMCDVIII'),
    </p>
    <p>
      (3501, 'MMMDI'),
    </p>
    <p>
      (3610, 'MMMDCX'),
    </p>
    <p>
      (3743, 'MMMDCCXLIII'),
    </p>
    <p>
      (3844, 'MMMDCCCXLIV'),
    </p>
    <p>
      (3888, 'MMMDCCCLXXXVIII'),
    </p>
    <p>
      (3940, 'MMMCMXL'),
    </p>
    <p>
      (3999, 'MMMCMXCIX'),
    </p>
    <p>
      (4000, 'MMMM'),&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; ----------------------------------------------1
    </p>
    <p>
      (4500, 'MMMMD'),
    </p>
    <p>
      (4888, 'MMMMDCCCLXXXVIII'),
    </p>
    <p>
      (4999, 'MMMMCMXCIX'))
    </p>
    <p>
      def testToRomanKnownValues(self):
    </p>
    <p>
      &quot;&quot;&quot;toRoman should give known result with known input&quot;&quot;&quot;
    </p>
    <p>
      for integer, numeral in self.knownValues:
    </p>
    <p>
      result = roman71.toRoman(integer)
    </p>
    <p>
      self.assertEqual(numeral, result)
    </p>
    <p>
      def testFromRomanKnownValues(self):
    </p>
    <p>
      &quot;&quot;&quot;fromRoman should give known result with known input&quot;&quot;&quot;
    </p>
    <p>
      for integer, numeral in self.knownValues:
    </p>
    <p>
      result = roman71.fromRoman(numeral)
    </p>
    <p>
      self.assertEqual(integer, result)
    </p>
    <p>
      class ToRomanBadInput(unittest.TestCase):
    </p>
    <p>
      def testTooLarge(self):
    </p>
    <p>
      &quot;&quot;&quot;toRoman should fail with large input&quot;&quot;&quot;
    </p>
    <p>
      self.assertRaises(roman71.OutOfRangeError, roman71.toRoman, 5000)-----------2
    </p>
    <p>
      def testZero(self):
    </p>
    <p>
      &quot;&quot;&quot;toRoman should fail with 0 input&quot;&quot;&quot;
    </p>
    <p>
      self.assertRaises(roman71.OutOfRangeError, roman71.toRoman, 0)
    </p>
    <p>
      def testNegative(self):
    </p>
    <p>
      &quot;&quot;&quot;toRoman should fail with negative input&quot;&quot;&quot;
    </p>
    <p>
      self.assertRaises(roman71.OutOfRangeError, roman71.toRoman, ?1)
    </p>
    <p>
      def testNonInteger(self):
    </p>
    <p>
      &quot;&quot;&quot;toRoman should fail with non?integer input&quot;&quot;&quot;
    </p>
    <p>
      self.assertRaises(roman71.NotIntegerError, roman71.toRoman, 0.5)
    </p>
    <p>
      class FromRomanBadInput(unittest.TestCase):
    </p>
    <p>
      def testTooManyRepeatedNumerals(self):
    </p>
    <p>
      &quot;&quot;&quot;fromRoman should fail with too many repeated numerals&quot;&quot;&quot;
    </p>
    <p>
      for s in ('MMMMM', 'DD', 'CCCC', 'LL', 'XXXX', 'VV', 'IIII'):&#160; --------------3
    </p>
    <p>
      self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, s)
    </p>
    <p>
      def testRepeatedPairs(self):
    </p>
    <p>
      &quot;&quot;&quot;fromRoman should fail with repeated pairs of numerals&quot;&quot;&quot;
    </p>
    <p>
      for s in ('CMCM', 'CDCD', 'XCXC', 'XLXL', 'IXIX', 'IVIV'):
    </p>
    <p>
      self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, s)
    </p>
    <p>
      def testMalformedAntecedent(self):
    </p>
    <p>
      &quot;&quot;&quot;fromRoman should fail with malformed antecedents&quot;&quot;&quot;
    </p>
    <p>
      for s in ('IIMXCC', 'VX', 'DCM', 'CMM', 'IXIV',
    </p>
    <p>
      'MCMC', 'XCX', 'IVI', 'LM', 'LD', 'LC'):
    </p>
    <p>
      self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, s)
    </p>
    <p>
      def testBlank(self):
    </p>
    <p>
      &quot;&quot;&quot;fromRoman should fail with blank string&quot;&quot;&quot;
    </p>
    <p>
      self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, &quot;&quot;)
    </p>
    <p>
      class SanityCheck(unittest.TestCase):
    </p>
    <p>
      def testSanity(self):
    </p>
    <p>
      &quot;&quot;&quot;fromRoman(toRoman(n))==n for all n&quot;&quot;&quot;
    </p>
    <p>
      for integer in range(1, 5000):&#160;&#160;&#160; --------------------------------------------4
    </p>
    <p>
      numeral = roman71.toRoman(integer)
    </p>
    <p>
      result = roman71.fromRoman(numeral)
    </p>
    <p>
      self.assertEqual(integer, result)
    </p>
    <p>
      class CaseCheck(unittest.TestCase):
    </p>
    <p>
      def testToRomanCase(self):
    </p>
    <p>
      &quot;&quot;&quot;toRoman should always return uppercase&quot;&quot;&quot;
    </p>
    <p>
      for integer in range(1, 5000):
    </p>
    <p>
      numeral = roman71.toRoman(integer)
    </p>
    <p>
      self.assertEqual(numeral, numeral.upper())
    </p>
    <p>
      def testFromRomanCase(self):
    </p>
    <p>
      &quot;&quot;&quot;fromRoman should only accept uppercase input&quot;&quot;&quot;
    </p>
    <p>
      for integer in range(1, 5000):
    </p>
    <p>
      numeral = roman71.toRoman(integer)
    </p>
    <p>
      roman71.fromRoman(numeral.upper())
    </p>
    <p>
      self.assertRaises(roman71.InvalidRomanNumeralError,
    </p>
    <p>
      roman71.fromRoman, numeral.lower())
    </p>
    <p>
      if __name__ == &quot;__main__&quot;:
    </p>
    <p>
      unittest.main()
    </p>
  </body>
</html></richcontent>
</node>
</node>
<node CREATED="1423012397560" ID="ID_1758567318" MODIFIED="1423013363459">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      1.The existing known values don't change (they're all still reasonable values to test), but you need to add a few more in the 4000 range. Here I've included 4000 (the shortest), 4500 (the second shortest), 4888 (the longest), and 4999 (the largest).
    </p>
    <p>
      [pope&#35793;]
    </p>
    <p>
      &#24403;&#21069;&#30693;&#36947;&#20540;&#24182;&#27809;&#26377;&#25913;&#21464;(&#23427;&#20204;&#20173;&#28982;&#26159;&#21512;&#29702;&#30340;&#27979;&#35797;&#20540;)&#65292;&#20294;&#20320;&#38656;&#35201;&#22312;4000&#30340;&#34892;&#21518;&#28155;&#21152;&#26356;&#22810;&#30340;&#27979;&#35797;&#25968;&#25454;&#12290;&#36825;&#37324;&#25105;&#21152;&#20837;&#20102;4000(&#26368;&#23567;&#20540;)&#65292;4500(&#31532;&#20108;&#23567;&#30340;&#20540;)&#65292;4888&#65288;&#36739;&#22823;&#20540;&#65289;&#65292;4999(&#26368;&#22823;&#20540;)
    </p>
  </body>
</html></richcontent>
</node>
<node CREATED="1423097588655" ID="ID_1899091307" MODIFIED="1423097989069">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      2.The definition of &quot;large input&quot; has changed. This test used to call toRoman with 4000 and expect an error; now that 4000-4999 are good values, you need to bump this up to 5000
    </p>
    <p>
      [pope&#35793;]
    </p>
    <p>
      &#23450;&#20041;&quot;&#26368;&#22823;&#36755;&#20837;&quot;&#30340;&#25913;&#21464;.&#36825;&#20010;&#27979;&#35797;&#20351;&#29992;&#30340;4000&#35843;&#29992;toRoman&#24182;&#19988;&#39044;&#26399;&#19968;&#20010;&#38169;&#35823;&#25243;&#20986;&#65292;&#29616;&#22312;4000&#65374;4999&#37117;&#26159;&#27491;&#24120;&#20540;&#65292;&#20320;&#38656;&#35201;&#20462;&#25913;&#20026;5000
    </p>
  </body>
</html>
</richcontent>
</node>
<node CREATED="1423099401449" ID="ID_757067352" MODIFIED="1423100654926">
<richcontent TYPE="NODE"><html>
  <head>
    
  </head>
  <body>
    <p>
      3.The definition of &quot;too many repeated numerals&quot; has also changed. This test used to call fromRoman with 'MMMM' and expect an error; now that MMMM is considered a valid Roman numeral, you need to bump this up to 'MMMMM'.
    </p>
    <p>
      [pope&#35793;] &quot;&#36807;&#22810;&#37325;&#22797;&#23383;&#31526;&quot;&#30340;&#23450;&#20041;&#20063;&#38656;&#35201;&#25913;&#21464;&#12290;&#36825;&#20010;&#27979;&#35797;&#20351;&#29992;&quot;MMMM&quot;&#35843;&#29992;fromRoman &#24182;&#19988; &#39044;&#26399;&#19968;&#20010;&#38169;&#35823;&#25243;&#20986;&#65292;&#29616;&#22312;MMMM&#34987;&#35748;&#20026;&#26159;&#19968;&#20010;&#26377;&#25928;&#20010;&#32599;&#39532;&#23383;&#31526;&#65292;&#20320;&#38656;&#35201;&#36319;&#26032;&#23427;&#20026;'MMMMM'.
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
</node>
</map>
